;
.define public LO                0
.define public HI                1

.define public AD0               0
.define public ACS               8
.define public AIRQ              9
.define public ARST             10
.define public AACK             11
.define public AA1              12
.define public ARW              13
.define public ADRQ             14
//.define public DATA_BUS         15
.define public ONBOARD_LED      25
.define public SYNC_O             21      ; dummy - use as output to trigger PIO


; on entry:
; gpio D0-D7 are inputs
; IRQ HI
.program try

.wrap_target                ; wait for new command
newCommand:
    set y, 5                ;side HI             ; initially expect command length of 6 bytes
    wait LO gpio AA1        ;side HI             ; got a new command byte
commandByte:
    wait LO gpio ACS        ;side HI  
    set pins HI             ;side HI             ; IRQ HI
    in pins 8               ;SIDE HI             ; read D0-D7 -> RXFIFO, autopush at 32bits (bytes 1-4)
    wait HI gpio ARW        ;SIDE HI
    jmp !y newCommand       ;side HI             ; if last byte, skip asserting IRQ ie. remains high

    set pins LO             ;side HI             ; IRQ LO
    jmp y-- commandByte     ;side HI             ; get next command byte
        
;complete:
;    nop                     ;side HI
    ;push noblock            side LO  [15]         ; should be pushing bytes 5 and 6 only, SYNC_O LO
        
.wrap                                   





% c-sdk {

#include "hardware/gpio.h"
#include "hardware/pio.h"


void try_program_init ( PIO pio, uint smid, uint offset ) 
{
    pio_sm_config c = try_program_get_default_config ( offset );
/*
    pio_gpio_init ( pio, AD0 );
    pio_gpio_init ( pio, 1 );
    pio_gpio_init ( pio, 2 );
    pio_gpio_init ( pio, 3 );
    pio_gpio_init ( pio, 4 );
    pio_gpio_init ( pio, 5 );
    pio_gpio_init ( pio, 6 );
    pio_gpio_init ( pio, 7 );
    */
    pio_gpio_init ( pio, AIRQ );
    //pio_gpio_init ( pio, AA1 );
    //pio_gpio_init ( pio, ARW );
    //pio_gpio_init ( pio, ACS );
    //pio_gpio_init ( pio, SYNC_O );
    //pio_gpio_init ( pio, ONBOARD_LED );

    pio_sm_set_consecutive_pindirs ( pio, smid, AD0,             8, false );  /* data lines D0-D7 initially inputs */
    //pio_sm_set_consecutive_pindirs ( pio, smid, ACS,             1, false );  /* CS input */
    pio_sm_set_consecutive_pindirs ( pio, smid, AIRQ,            1, true  );  /* IRQ output */
    //pio_sm_set_consecutive_pindirs ( pio, smid, AA1,             2, false );  /* A1, RW inputs */
    //pio_sm_set_consecutive_pindirs ( pio, smid, SYNC_O,          1, true  );  /* SYNC_OUT output */
    //pio_sm_set_consecutive_pindirs ( pio, smid, ONBOARD_LED,     1, true  );  /* SYNC_OUT output */

    //sm_config_set_sideset_pins ( &c, SYNC_O );
    sm_config_set_set_pins     ( &c, AIRQ, 1 );
    sm_config_set_in_pins      ( &c, AD0 );
    //sm_config_set_out_pins     ( &c, ONBOARD_LED, 1 );

    sm_config_set_in_shift     ( &c, true, true, 32 ); /* autopush, filled on 32 bits */
    
    //sm_config_set_in_shift     ( &c, true, true, 8 ); /* autopush, filled on 8 bits */
    //sm_config_set_fifo_join    ( &c, PIO_FIFO_JOIN_RX ); /* need 6 bytes to not stall the SM */

    //pio->input_sync_bypass = 0;

    pio_sm_init ( pio, smid, offset, &c );
    pio_sm_set_enabled ( pio, smid, true );
}

%}




;
.program statusPhase

;.side_set HI                            ; DATA BUS enable/disable

;.wrap_target
    pull block 
    set pins LO         ;side HI         ; IRQ low
    wait HI gpio ARW    ;side HI         ; must be doind a READ (us -> ATARI)
    
    mov osr, ~null      ;side HI
    out pindirs 8       ;side HI         ; change data-bus direction - OUT (Peripheral -> ATARI)
    
    wait LO gpio ACS    ;side LO   
    set pins HI         ;side LO         ; IRQ high

    ; get status byte from FIFO
    ;pull block          ;side HI         ; get status byte from FIFO
    out pins 8          ;side HI         ; write byte to data-bus

    wait LO gpio ARW    ;side LO   

    mov osr, ~null      ;side HI
    out pindirs 8       ;side HI         ; change data-bus direction - IN (ATARI -> Peripheral)
;.wrap
     



% c-sdk {

#include "hardware/gpio.h"


void statusPhase_program_init ( PIO pio, uint smid, uint offset ) {

    pio_sm_config c = statusPhase_program_get_default_config ( offset );

    pio_gpio_init ( pio, AIRQ );

    //pio_sm_set_consecutive_pindirs ( pio, smid, AD0,             8, false  );  /* data lines D0-D7 inputs */
    //pio_sm_set_consecutive_pindirs ( pio, smid, ACS,             1, false );  /* CS input */
    pio_sm_set_consecutive_pindirs ( pio, smid, AIRQ,            1, true  );  /* IRQ output */
    //pio_sm_set_consecutive_pindirs ( pio, smid, ARW,             1, false );  /* RW inputs */
    //pio_sm_set_consecutive_pindirs ( pio, smid, ADRQ,            1, true  );  /* DRQ output */
    //pio_sm_set_consecutive_pindirs ( pio, smid, DATA_BUS,        1, true  );  /* data bus enable output */
    //pio_sm_set_consecutive_pindirs ( pio, smid, FIRE,            1, true  );  /* external trigger */

    
    sm_config_set_set_pins     ( &c, AIRQ, 1 );
    sm_config_set_out_pins     ( &c, AD0, 8 );
    sm_config_set_out_shift    ( &c, true, false, 8 ); /* shift right, no autopull */

    pio_sm_init ( pio, smid, offset, &c );
    pio_sm_set_enabled ( pio, smid, true );
}

%}